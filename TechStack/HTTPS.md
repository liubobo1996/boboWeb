# 目录
- 摘要
- 加密
    - 对称加密
    - 非对称加密
    - 对称加密和非对称加密区别
    - 中间人攻击
- 证书系统和HTTPS
    - 签名
    - 证书和HTTPS
        - HTTPS简化流程：如何解决服务器公钥不可信
        - 权威机构审核申请
        - 算法依赖
        - 重放攻击
        - 防止重放攻击

### [摘要]
  * 定义: 通过给定的摘要算法和任意长度的文本, 生成定长的文本, 这种文本就叫摘要
  * 特点: 不可逆性, 不能还原出原数据
  * 用途: 检查数据是否被篡改; 服务器通过存储密码的摘要而不是明文存储密码的方式, 保护密码
  * 常见算法: md5, sha1, sha256
  * 示例代码: digestEample.java
  * 彩虹表 保存常见原文和摘要的对应关系
  * 加盐 用(用户密码+某自定义字符串)来生成摘要    

### [加密]
  * 特点: 可逆性, 一定能还原出原数据

#### 1. 对称加密
  * 服务器和浏览器用同一个密钥进行加密和还原(类似密码本)
  * 特点: 加密和解密速度快 (大概速度是非对称加密的1000倍)
  * **问题1: 密钥被截获**
    ```
    解决办法: 非对称加密
    浏览器第一次访问服务器 双方交换自己的公钥
    双方使用对方的公钥加密 使用自己的私钥解密
    这样其他人就算截获公钥 也无法获知原文
    ```
  * 常见算法: AES
  * 示例代码: AESEncryptDemo.java

#### 2. 非对称加密
  * 原理
    * 通过指定算法生成一对密钥, 分为公钥和私钥
    * 公钥加密的, 私钥可以解密, 私钥加密的, 公钥可以解密
  * 特点: 加密和解密速度慢
  * 常见算法: RSA
  * 代码片段
  * 示例代码: RSAEncryptDemo.java
    ```
    // 公钥加密 得到密文
    byte[] cipherText = encrypt(message.getBytes(StandardCharsets.UTF_8), privateKey);
    // 私钥解密 得到原文
    byte[] origin = decrypt(cipherText, publicKey);
    ```
  * **问题2: 公钥被掉包(中间人攻击)**
    ```
    解决办法: 证书系统
    ```

#### 3. 对称加密和非对称加密区别
  * 对称加密中加密和解密使用的密钥是同一个; 非对称加密中采用两个密钥，一般使用公钥进行加密，私钥进行解密
  * 对称加密的加解密速度快; 非对称加密的加解密速度慢
  * 对称加密的安全性相对较低; 非对称加密的安全性较高

#### 4. 中间人攻击
  * 交换密钥阶段:
    * 浏览器 --- 浏览器公钥 --> 中间人 --> 中间人公钥 --> 服务器
    * 浏览器 <--- 中间人公钥 --- 中间人 <-- 服务器公钥 --- 服务器
    * 公钥掉包: 浏览器和服务器都以为自己拿到了对方的公钥, 其实拿到的都是中间人公钥
  * 数据传输阶段:
    ```
    -----       中间人公钥加密的信息          服务器公钥加密的信息      -----
    丨浏丨    -------------------->         -------------------->     丨服丨
    丨览丨                          中间人                            丨务丨
    丨器丨                      (拥有双方公钥)                        丨器丨
    丨  丨   <--------------------           <--------------------    丨  丨
    -----       浏览器公钥加密的信息          中间人公钥加密的信息      -----
    ```
    * 中间人从浏览器处获取信息后, 使用自己的私钥解密, 获得原文
    * 中间人将原文篡改后, 使用服务器公钥加密, 发送给服务器
    * 服务器拿到信息后使用自己的私钥解密, 所以服务器不知道原文篡改以及公钥掉包, 浏览器端同理

### [证书系统和HTTPS]
#### 1. 签名
  * **传输格式:**
    * 数据 + 签名(用发信人私钥加密的摘要)
  * **定义**:
    * 发信人对数据做一个摘要, 然后用发信人私钥加密此摘要, 这个**加密后的摘要就叫签名**, 数据和签名一起发送
    * 收信人用发信人公钥解密签名, 获得摘要A, 然后自己也对数据做一个摘要, 获得摘要B
    * 如果A=B, 就能**保证信息没有被篡改**, 但是**不能保证信息不可见**
  * **如何保证信息没有被篡改**
    * 中间人截取信息, 修改后再发送, 此时有两种情况:
      1. 修改后的数据 + 签名Q(发信人私钥加密)
        * 收信人收到修改后的数据和签名Q, 解密签名Q获得摘要A, 对修改后的数据做一个摘要, 获得摘要B
        * 摘要 A: 原来的数据计算而来
        * 摘要 B: 修改后的数据计算而来
        * 摘要 A != 摘要 B
      2. 修改后的数据 + 签名q(中间人私钥加密)
        * 收信人收到修改后的数据和签名q
        * 收信人解密签名q失败

#### 2. 证书和HTTPS
###### **HTTPS简化流程：如何解决服务器公钥不可信**
  ```
                提交服务器公钥等信息 申请服务器证书
          ----------------------------------------------->
  [服务器]                                                 [权威机构] 对服务器公钥等信息签名
          <-----------------------------------------------       (用自己私钥加密)
            颁发服务器证书 (服务器公钥+其他信息+权威机构签名)
  ```
  ```
      [浏览器]        发送服务器证书
  内置权威机构公钥  <---------------- [服务器]
      (根证书)
  ```
  ```
                      获得服务器证书
            得到服务器公钥+其他信息+权威机构签名
  [浏览器]    用权威机构公钥解密签名 获得摘要A
            自己对服务器公钥做一个摘要 获得摘要B
             A=B 则该服务器公钥经过权威机构认证
  ```
  ```
            对话密钥（用服务器公钥加密）
  [浏览器] ---------------------------> [服务器] 用自己的私钥解密
  ```
  ```
      <身份认证和密钥协商成功 开始正式通信>

            数据(用对话密钥加密)
  [浏览器] -----------------------> [服务器]
          <-----------------------
            数据(用对话密钥加密)
  ```

###### 权威机构审核申请
  * 服务器提交证书申请之后, 权威机构发送一个字符串S, 要求能够在该服务器的域名里或者服务器上找到S
  * 由于全世界浏览器数量过多 像给服务器一样给每个浏览器颁发证书不现实
    所以实际生活中用对称加密来加密数据服务器和浏览器交换公钥

###### 算法依赖
  * HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS
  * HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议
  * TLS/SSL 的功能实现主要依赖于三类基本算法：
    1. 散列函数: 基于散列函数验证信息的完整性(摘要)
    2. 对称加密: 采用协商的密钥加密数据
    3. 非对称加密: 实现身份认证和密钥协商

###### 重放攻击
```
原始请求
1. 浏览器 -> 我要建立请求 -> 服务器
2. 浏览器 <-  服务器证书  <-  服务器
3. 浏览器 -> 服务器证书加密("对称秘钥") ->  服务器
4. 浏览器 -> 对称秘钥("gua 账户扣钱 500") -> 服务器
```
```
重放攻击(中间人记录了浏览器发过服务器的请求)
1. 中间人 -> 我要建立请求 -> 服务器
2. 中间人 <-  服务器证书  <-  服务器
3. 中间人 -> 服务器证书加密("对称秘钥") ->  服务器
4. 中间人 -> 对称秘钥加密("gua 账户 扣钱 500") -> 服务器
```

###### 防止重放攻击
```
1. 浏览器 -> 我要建立请求 + 随机数 1 -> 服务器
2. 浏览器 <-  服务器证书 + 随机数 2  <-  服务器
3. 浏览器 -> 服务器证书加密("pre_master_key") ->  服务器 (随机数 1 + 随机数 2 + pre_master_key -> 生成密钥)
4. 浏览器 -> "随机数1 + 随机数2 + pre_master_key"加密("gua 账户扣钱 500") -> 服务器
```
```
1. 中间人 -> 我要建立请求 + 随机数 1 -> 服务器
2. 中间人 <-  服务器证书 + 随机数 3  <-  服务器
3. 中间人 -> 服务器证书加密("pre_master_key") ->  服务器 (随机数 1 + 随机数 3 + pre_master_key -> 生成密钥)
4. 中间人 -> "随机数1 + 随机数2 + pre_master_key"加密("gua 账户扣钱 500") -> 服务器
```
