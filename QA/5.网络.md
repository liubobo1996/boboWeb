# 目录
- TCP/IP 四层模型
- TCP UDP
    - 区别
    - 三次握手
    - 四次挥手
    - TCP 如何保证传输可靠性
- HTTP HTTPS
- Cookie Session
- 摘要 加密
    - 摘要
    - 加密
        - 对称加密
        - 非对称加密
        - 中间人攻击
- 证书体系
    - 算法依赖
    - 签名
    - 证书
    - 重放攻击及防止

### TCP/IP 四层模型
```bash
# 应用层 Application Layer
# 协议: HTTP SMTP 等
为两个终端设备的应用程序提供信息交换服务, 定义信息交换格式, 报文信息由传输层传输

# 传输层 Transport Layer
# 协议: TCP UDP 等
为两个终端设备的进程提供信息传输服务, 将报文分割成 TCP 数据包, 不同类型的应用程序可用同一传输层服务

# 网络层 Network Layer
# 协议: IP NAT ARP 等
    # NAT, Network Address Translation, 网络地址转译, 内网 IP 转外网 IP
    # ARP, Address Resolution Protocol, 地址解析协议, IP 转 MAC
为分组交换网上的不同主机提供通信服务, 将 TCP 数据包封装成 IP 数据包, 通过选择合适的路由找到目的主机

# 网络接口层 Network interface layer
# 协议: MAC 等
1. 数据链路层, 将 IP 数据包组装成包含数据和控制信息的帧, 在相邻节点的链路上传送
2. 物理层, 在相邻计算机节点之间传送比特流, 尽可能屏蔽传输介质和设备的差异
```

### TCP UDP
```bash
# 区别
TCP, Transmisson Control Protocol, 传输控制协议, 面向连接, 保证数据传输可靠性, 用于文件传输, 收发邮件, SSH 登录等
UDP, User Datagram Protocol, 用户数据报协议, 无连接, 不保证数据传输可靠性, 用于语音、视频、直播等即时通信
```
```bash
# 三次握手
              x
Client --------------> Server
            x+1,y
Client <-------------- Server
             y+1
Client --------------> Server

Server 确认对方能发送, 自己能接收 # 三次握手才能确认双方的收发功能都正常
Client 确认自己能发送, 对方能接收, 对方能发送, 自己能接收
Server 确认自己能发送, 对方能接收
```
```bash
# 四次挥手
              x
Client --------------> Server
             x+1
Client <-------------- Server # Client 如果没收到 x+1 将重新发送 x
              y
Client <-------------- Server
             y+1
Client --------------> Server # Server 如果没收到 y+1 将重新发送 y
                              # Client 发送 y+1 后等待最大往返时延, 期间:
                                  # 1. 收到了 Server 重新发送的 y, Client 重新发送 y+1, 继续等待最大往返时延
                                  # 2. 没收到 Server 重新发送的 y, 关闭 TCP 连接

Client: 我说完了 # TCP 可以双向传输数据
Server: 知道了, 继续巴拉巴拉
Server: 我说完了
Client: 知道了
```
```bash
# TCP 如何保证数据传输可靠性
1. 基于 TCP 数据包传输
2. 排序去重 # 给包编号
3. 校验和 # 类似摘要 确保数据前后一致
4. 超时重传 # 发送 x 然后等待一段往返时延 (RTT), 未收到 x+1 则重传
5. 流量控制 # 滑动窗口: 通过接收方发送的确认报文 (x+1) 的窗口字段控制发送方的发送速率
6. 拥塞控制 # 网络拥塞 (se, 四声)时, 减少数据发送
```

### HTTP HTTPS
```bash
HTTP: 80 端口, http:// 前缀, 明文传输, 无法验证对方身份
HTTPS: 443 端口, https:// 前缀, 通过散列函数 (摘要) 实现信息完整性保护, 通过非对称加密完成身份认证和密钥协商, 通过协商好的对话密钥对数据进行对称加密后传输
```

### Cookie Session
```bash
# 1. Cookie 记住用户状态
1. 浏览器登录
2. 服务器在响应头增加字段 # set-cookie: name=bobo
3. 浏览器保存 cookie, 之后访问服务器时在请求头增加字段 # cookie: name=bobo

# 2. Session 在记住用户状态的基础上解决伪造
1. 浏览器登录
2. 服务器验证登录, 生成一个 sessionId (token), 保存 sessionId 到 userId 的映射
3. 服务器在响应头增加字段 # Set-Cookie: session_id=随机字符串
4. 浏览器保存 session_id, 之后访问服务器时在请求头增加字段 # cookie: session_id=随机字符串
5. 服务器接收 session_id 并查找对应用户
```

### 摘要 加密
```bash
# 摘要
原理: 通过给定的摘要算法和任意长度的文本, 生成定长的文本
特点: 不可逆性, 不能还原数据, 用于检查数据是否被篡改
# 用例: 密码加盐 # hash = md5(password + salt)
```
```bash
# 加密
特点: 可逆性, 能够还原数据

# 对称加密
原理: 服务器和浏览器用同一个对话密钥进行加密和还原 # 类似密码本
特点: 加密和解密速度快, 安全性较低 # 大概速度是非对称加密的1000倍
问题: 密钥被截获 # 用非对称加密解决

# 非对称加密
原理: 通过算法生成一对密钥 (公钥和私钥), 一方加密的另一方可以解密
特点: 加密和解密速度慢, 安全性较高
问题: 中间人攻击 (公钥被调包) # 用证书解决

# 中间人攻击

# 1. 交换公钥阶段
# 浏览器 --- 浏览器公钥 --> 中间人 --> 中间人公钥 --> 服务器
# 浏览器 <--- 中间人公钥 --- 中间人 <-- 服务器公钥 --- 服务器
公钥掉包: 浏览器和服务器都以为自己拿到了对方的公钥, 其实拿到的都是中间人公钥

# 2. 数据传输阶段
#       中间人公钥加密的信息            服务器公钥加密的信息     
# 浏   -------------------->         -------------------->   服
# 览                          中间人                         务
# 器                      (拥有双方公钥)                     器
#      <--------------------         <--------------------    
#       浏览器公钥加密的信息            中间人公钥加密的信息      
中间人从浏览器处获取信息后, 使用自己的私钥解密, 获得原文
中间人将原文篡改后, 使用服务器公钥加密, 发送给服务器
服务器拿到信息后, 使用自己的私钥解密, 未发现原文篡改以及公钥掉包, 浏览器端同理
```
### 证书体系
```bash
# 算法依赖
1. HTTPS = HTTP + 信息完整性保护 + 身份认证 + 密钥协商 + 信息对称加密
2. HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议, TLS/SSL 的功能实现主要依赖于三类基本算法
    1. 散列函数: 实现信息完整性保护 (摘要)
    2. 非对称加密: 实现身份认证和密钥协商
    3. 对称加密: 实现信息对称加密后传输
```
```bash
# 签名
    # 只能保证第二阶段 (数据传输) 的信息不被篡改
    # 中间人如果在第一阶段 (交换公钥) 拿到双方公钥, 信息将对中间人可见

1. 客户端
                客户端私钥加密
data -> 摘要 A ---------------> 签名 S                [发送 data + S]

2. 服务器
                           data -> 摘要 B
[收到 data + S]                                       [验证 A = B ?]
                            客户端公钥解密
                    签名 S ---------------> 摘要 A
# A = B 则数据没有被篡改, 但不能保证信息不可见

# 如何保证

# 1. 中间人
[收到 data + S]   data -> data2   [发送 data2 + S]
# 2. 服务器
                           data2 -> 摘要 C
[收到 data2 + S]                                      [发现 A != C]
                            浏览器公钥解密
                    签名 S ---------------> 摘要 A
#####################################################################
# 1. 中间人
                        data -> data2 -> 摘要 C
[收到 data + S]                                       [发送 data2 + S2]
                            中间人私钥加密
                    摘要 C ---------------> 签名 S2
# 2. 收信人
                           data2 -> 摘要 C
[收到 data2 + S2]
                            浏览器公钥解密
                    签名 S ---------------> [解密失败]
```

```bash
# 证书
    # 实现第一阶段 (交换公钥) 的身份认证和密钥协商
    # 第二阶段 (数据传输) 用协商好的对话密钥先对数据进行对称加密

# 1. 服务器申请证书, CA 颁发证书 (CA 审核类似备案号审核)
              提交信息 (含服务器公钥) 申请服务器证书
        ----------------------------------------------->
[服务器]                                                 [CA]   对信息签名
                                                             (摘要 + 私钥加密)
        <-----------------------------------------------       
          颁发服务器证书 (信息 + CA 签名)

# 2. 服务器发送证书给浏览器
    [浏览器]        发送服务器证书
内置 CA 公钥  <---------------- [服务器]
    (根证书)

# 3. 浏览器验证服务器证书
            获得服务器证书 (信息 + CA 签名)
[浏览器]     用 CA 公钥 (根证书) 解密签名, 获得摘要 A
            自己对信息做一个摘要, 获得摘要 B
            A = B, 从信息中提取服务器公钥

# 4. 浏览器发送对话密钥给服务器
          对话密钥（用服务器公钥加密）
[浏览器] ---------------------------> [服务器] 用自己的私钥解密

# 5. 身份认证和密钥协商成功 开始正式通信
          数据(用对话密钥加解密)
[浏览器] -----------------------> [服务器]
        <-----------------------
          数据(用对话密钥加解密)
```

```bash
# 重放攻击及防止

# 原始请求
1. 浏览器 -> 我要建立请求 -> 服务器
2. 浏览器 <-  服务器证书  <-  服务器
3. 浏览器 -> 服务器证书加密 (对话密钥) ->  服务器
4. 浏览器 -> 对话密加密 (-500) -> 服务器
# 重放攻击成功 (中间人记录了浏览器发过的请求)
1. 中间人 -> 我要建立请求 -> 服务器
2. 中间人 <-  服务器证书  <-  服务器
3. 中间人 -> 服务器证书加密 (对话密钥) ->  服务器
4. 中间人 -> 对话密钥加密 (-500) -> 服务器

# 原始请求 (r 表示随机数)
1. 浏览器 -> 我要建立请求 + r1 -> 服务器
2. 浏览器 <- 服务器证书 + r2  <- 服务器
3. 浏览器 -> 服务器证书加密 (preKey) -> 服务器
4. 浏览器 -> 对话密钥加密 (-500) -> 服务器 # 对话密钥 = r1 + r2 + preKey
# 重放攻击失败
1. 中间人 -> 我要建立请求 + r1 -> 服务器
2. 中间人 <- 服务器证书 + r3 <- 服务器
3. 中间人 -> 服务器证书加密(preKey) -> 服务器 # 对话密钥 = r1 + r3 + preKey
4. 中间人 -> 对话密钥加密 (-500) -> 服务器 # 扣款失败
```
