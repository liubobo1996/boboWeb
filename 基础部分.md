# 第一部分: Java相关

### 1.面向对象和面向过程
    - 什么是面向对象, 什么是面向过程
    - 面向对象的三个特点, 封装, 继承, 多态

```
面向过程:
检测
整数+
整数-
检测
小数+
小数-
```

```
面向对象:
整数{           // 封装: 将属性和方法封装到一个抽象的类中
  检测
  +
  -
}
小数{
  检测
  +
  -
}
```

```
面向对象2:
数{            // 父类 如果不写函数具体实现就是抽象类
  检测
  +
  -
}

整数{          // 继承: 子类具有父类的属性和方法或者重新定义、追加属性和方法等
  继承父类设计   
}             // 多态:针对数的方法调用，执行方法取决于运行时期实际类型是整数还是小数

小数{
  继承父类设计
}

```
### 2.重载和重写有什么不同
    - 解释什么是重载, 什么是重写

```
重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
sum(a,b)
sum(a,b,c)
重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
数.sum()
整数.sum()
子类中重写sum()的具体实现
```

### 3.构造器(构造方法)
    - 什么是构造方法
    - new 的时候, 如果有多个构造方法怎么选择构造方法
    - super 的用法  https://www.liaoxuefeng.com/wiki/1252599548343744/1260454548196032

```
1.创建实例时初始化实例字段的方法
2.编译器通过构造方法的参数数量、位置和类型自动区分
3.
  用法一 调用父类属性 super.name
  用法二 调用父类的构造方法 super()
```
### 4.自动装箱和拆箱
    - 基本类型和引用类型的装换

```
为什么要有包装器类型:
1. 包装类里面有一些很有用的方法和属性，如HashCode,ParseInt
2. 基本类型不能赋null值，某些场合需要。
            - 比如int默认值为0无法定义缺考 通过Integer的NULL实现
3. 有些地方不能直接用基本类型，比如HashMap

装箱：基本类型->对应引用类型(包装类型)       int->Integer
拆箱：包装类型->基本类型                   Integer->int

示例:
Integer dabobo = new Integer(10);  // 手动装箱
int xiaobobo = dabobo.intValue();  // 手动拆箱

Integer dabobo  = 10;  // 自动装箱
    - 当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。
int xiaobobo = dabobo;     // 自动拆箱
```


### 5.静态方法和实例方法
    - 什么是静态方法, 什么是实例方法
    - 如何调用
    - 方法中能否访问实例

```
静态方法(类方法):
      1.类中用static修饰的方法 2.调用形式 类名.方法名 3.不能访问实例
实例方法:
      1.类中不用static修饰的方法 2.调用形式 实例.方法名 3.允许访问实例


```
### 6.成员(实例)变量与局部变量
    - 什么是成员变量, 什么是局部变量
    - 在内存中的存储方式
    - 拓展: 是否有默认值

```
成员(实例)变量:
定义在类中,在整个类中都可以被访问,修饰符:public private static ✅final✅
随着对象的建立而建立,随着对象的消失而消失,存在于对象所在的堆内存中.
有默认值

局部变量:
在方法中定义的变量或是方法的参数,修饰符:public private static ❌final✅
局部变量存在于栈内存中,作用的范围结束,变量空间会自动释放.
无默认值
```
### 7.接口和抽象类:
    - 定义方法
    - 区别

```
抽象类
abstract class Person {
    public abstract void run();
}
接口
interface Person {
    void run();
}
如果一个抽象类没有字段,所有方法全部都是抽象方法,就可以把该抽象类改写为接口
```
### 8.泛型
    - 泛型的本质,泛型的优点
    - 泛型的三种使用方式
    <!-- - 拓展: Java 泛型的局限性 -->

```
泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数
编译的时候检查类型安全，并能捕捉类型不匹配的错误，并且所有的强制转换都是隐式的和自动的，提高代码的复用率。

泛型的三种使用方式
1.泛型类
2.泛型接口
3.泛型方法


```

### 9.垃圾回收和垃圾回收算法
    - 什么是垃圾回收
    - 有哪些垃圾回收算法
    - 新生代, 老年代 的回收策略

```
1.释放垃圾占用的空间，防止内存泄露

2.
  标记-复制 标记-清理 标记-整理 分代收集
3.
当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
```

### 10.什么是线程和进程, 有什么区别, wait()和sleep()的共同点和区别
```
定义:
进程是程序的一次执行过程，是系统运行程序的基本单位
线程与进程相似，但线程是一个比进程更小的执行单位

区别:
线程在进程下行进（单纯的车厢无法运行）
一个进程可以包含多个线程（一辆火车可以有多节车厢）
不同进程间数据很难共享（A火车换到B火车很不易，比如站点换乘）同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
进程要比线程消耗更多的计算机资源（一列火车比一节车厢更耗资源）
各进程是独立的 而各线程则不一定 因为同一进程中的线程极有可能会相互影响 (A火车出事不会影响B火车 A车厢出事可能影响B车厢)
线程使用的内存地址可以上锁 即一个线程使用某些共享内存时 其他线程必须等它结束 才能使用这一块内存 （比如火车上的洗手间）－"互斥量"
线程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入 如果满了需要在门口等 等有人出来了才能进去）－“信号量”

wait()和sleep():
共同点:两者都可以暂停线程的执行。
区别在于：
1. wait() 方法释放了锁,sleep() 方法没有释放锁
2. wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。
3. wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者
notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。
```

### 11.线程同步,死锁, synchronized 和 volatile
```
线程同步
1.理解
相对于现实中的“排队”,几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。
2.线程不同步带来的问题
多个线程来访问同一个数据时，非常容易出现线程安全问题(比如多个线程都在操作同一数据导致数据不一致)

死锁
1.理解
线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
2.必要条件
  - 互斥条件：该资源任意一个时刻只由一个线程占用。
  - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
  - 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
  - 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
3.避免死锁
  - 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
  - 破坏请求与保持条件 ：一次性申请所有的资源。
  - 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
  - 破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。


synchronized
1.用途:解决多个线程之间访问资源的同步性 被该关键字修饰的方法或代码块在任意时刻只能有一个线程执行
2.使用方式:
  - 修饰实例方法
  - 修饰静态方法
  - 修饰代码块

volatile
1.并发编程的三个特性
  - 原子性 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。
  - 可见性 当一个线程对共享变量进行了修改 其他线程立即可以看到修改后的值 volatile保证了共享变量的可见性
  - 有序性 代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。
2.volatile如何保证可见性
  在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。
  把变量声明为volatile,指示JVM该变量共享且不稳定的,每次使用它都要到主存中读取.
```

### 12.栈和堆
    - 什么是栈, 什么是堆
    - 存储哪些数据
```
堆
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
栈(虚拟机栈)
线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
```

### 13.异常
```
Throwable:
  所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception 和 Error 。

Exception :
  程序本身可以处理(catch捕获/throw抛出)的异常，
  Exception 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。
  除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常

Error ：
  程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。
  例如，Java 虚拟机运行错误（Virtual MachineError）虚拟机内存不够错误(OutOfMemoryError)等 。
  这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

try-catch-finally:
  try块 用于捕获异常
  catch块 用于处理捕获到的异常
  finally块 无论是否捕获或处理都会执行
```

### 14.JDK JRE JVM 分别是什么
```
JDK包含JRE包含JVM

JDK ：
  （Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 JRE 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。

JRE ：
  （Java Runtime Environment），Java 运行时环境。它主要包含两个部分，JVM 的标准实现和 Java 的一些基本类库。

JVM ：
  （Java Virtual Machine），Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心
```
### 15.Char 和 String 有什么不同
```
形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符

含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)

占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节),
```
### 16.String, StringBuilder 和 StringBuffer 的区别
    - 线程是否安全

```
String:
  不可变 可以理解为常量 线程安全
  每次修改生成一个新的 String 对象，然后将指针指向新的 String 对象
  适用于操作少量数据    
StringBuilder:
  可变 没有对方法加同步锁 非线程安全
  对 StringBuilder 对象本身操作
  适用于单线程下操作大量数据
StringBuffer:
  可变 对方法加了同步锁 线程安全
  对 StringBuffer 对象本身操作
  适用于多线程下操作大量数据
```

### 17.Java 当中的 String 为什么是不可变的
```
private final byte[] value
String 类中使用 final 关键字修饰 byte 数组来保存字符串，所以String 对象是不可变的。
The
```

### 18.== 与 equals ; hashcode与equals
    - == 和 equals 的区别
    - hashcode 和 equals 的区别

```
==和equals
== :
  它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象
  (基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。
equals() :
  它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
    情况 2：类覆盖了 equals() 方法。一般，我们覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。


hashcode和equals
1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有  
例如内存中有这样的位置  0  1  2  3  4  5  6  7    
而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，
如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。  但如果用hashcode那就会使效率提高很多。  
我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。  

2.但是如果两个类有相同的hashcode怎么办（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。
那么如何判断呢？在这个时候就需要定义 equals了。  
也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。  
那么。重写了equals()，为什么还要重写hashCode()呢？  想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 。

```

### 19.List Set Map:
    - 区别, 有序, 是否可重复

```
List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。
Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。
Map(用 Key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，"y"代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。
```

### 20.动态代理
    - 动态代理是什么 项目的哪个框架依赖了动态代理

```
静态代理:
1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

动态代理:
1. 不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。
2. 从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。
3. 项目中的 Spring AOP的实现依赖了动态代理。
4. 动态代理的实现方式
  1.JDK 动态代理
  2.Cglib 动态代理


```

### 21.内存模型
    - 哪些区域, 存储什么信息
    - String 和常量池
```
见桌面图
```

### 22.什么是MVC
    - M, V, C 分别是什么
    - 为什么要用 MVC 模式

```
M model 系统涉及的数据
V view 视图渲染(类比填表格)
C controller 控制器 负责接收请求 调用对应路由 派发页面

web开发存在一些问题 如控制逻辑和表现逻辑混在一起 前端和后端相互依赖 重复造轮子
因此诞生了MVC模式 目的是帮助我们进行更简洁的web开发
```

# 第二部分: 网络

### 23.HTTP 和 HTTPS
    - HTTP
        - 结构(请求行, 请求发放, 请求头, body 等等)
    - HTTPS
        - 和 http 的区别
        - 具体的传输过程
```

—————————————————————————GET请求
GET /search?name=gua&height=169 HTTP/1.1    
Connection: Keep-Alive

body
—————————————————————————POST请求
POST /search HTTP/1.1
 Content-Type:application/x-www-form-urlencoded 

name=gua&height=169
—————————————————————————响应
HTTP/1.1 200 OK 
Date: Fri, 22 May 2009 06:07:21 GMT
 Content-Type: text/html; charset=UTF-8

body
—————————————————————————

端口 ：
  HTTP的URL由“http://”起始且默认使用端口80，
  HTTPS的URL由“https://”起始且默认使用端口443。

安全性和资源消耗：
  (皮卡)HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
  (面包车)HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。

所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

SSL/TLS:
SSL (Secure Sockets Layer 安全套接层)
原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。
到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（Transport Layer Security 传输层安全协议）
```

### 24.Cookie 和 Session
    - Cookie 是什么, 怎么设置
    - Session 是什么, 怎么实现
    - 两者的关系
```
Cookie:
  用来跟踪浏览器用户身份的会话方式 一般用来保存用户信息

  用户名为tony的已注册用户登录时
  服务器在登录相关的路由函数中
  给header加上字段Set-Cookie: username=tony
  此后用户tony发出的请求头会带上字段username=tony

Session:
  用来跟踪浏览器用户身份的会话方式 通过服务器记录用户状态

  1. 客户端向服务器发送请求
  2. 服务器给客户端分配sessionID, 根据sessionID临时保存用户信息, 并设置过期时间
  3. 客户端保存sessionID 之后每次发送请求都带上sessionID

Cookie和Session的关系
  0. 都是用来跟踪浏览器用户身份的会话方式
  1. Cookie存储在客户端(浏览器) Session存储在服务器
  2. Session安全性更高
  3. 应用场景不同 Cookie一般用来保存用户信息 Session通过服务器记录用户状态

```
### 25.jwt
    - 是什么
    - 几部分组成
    - 用处

```
JWT（JSON Web Token）是一种身份认证的方式，JWT 本质上是一段带有签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性
```

### 26.TCP 和 UDP 的区别, 三次握手, 四次挥手
```
TCP vs UDP:
UDP [喊话]在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

TCP [双向传送带]提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

三次握手:
第一次握手：
  客户端给服务端发一个 SYN (synchronize)报文，并指明客户端的初始化序列号 100。此时客户端处于 SYN_SEND 状态。
第二次握手：
  服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 200。同时会把客户端的 100 + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
第三次握手：
  客户端收到 SYN 报文之后，会发送一个 ACK (acknowledge)报文，当然，也是一样把服务器的 200 + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

为什么需要三次握手:
第一次握手：
  客户端发送网络包，服务端收到了。
  这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：
  服务端发包，客户端收到了。
  这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。
  不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：
  客户端发包，服务端收到了。
  这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
因此，需要三次握手才能确认双方的接收与发送能力是否正常。


四次挥手:
(双向传送带)
客户端- 发送一个 FIN(finish)，关闭客户端到服务器的数据传送
服务器- 收到这个 FIN，发回一个ACK，确认序号为收到的序号加1
服务器- 发送一个 FIN，关闭服务器到客户端的数据传送
客户端- 发回 ACK 报文确认，并将确认序号设置为收到序号加1

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。
```

### 27.TCP/IP 四层模型
    - 哪四层, 作用
    - http 和 ip 在哪层, tcp 和 udp 在哪一层

```
应用层 应用进程间的交互规则                            --客户端在应用层发送HTTP请求   
传输层 提供数据传输服务                               --在传输层（TCP）加入端口号
网络层 选择合适的网间路由和交换结点，确保数据及时传送      —-在网络层（IP）加入IP地址
数据链路层 将网络层交下来的 IP 数据报组装成帧并传送       --在数据链路层加入MAC地址

HTTP在应用层 IP在网络层 TCP和UDP在传输层
```

### 28.跨域和跨域限制访问
    - 什么是跨域限制访问
    - 怎样的请求会造成跨域
    - 怎么解决
```
指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。

a页面想获取b页面资源，如果a、b页面的协议、域名(包括子域名)、端口存在不同，所进行的访问都是跨域的

用nginx(类比菜鸟驿站)作为代理服务器和用户交互，这样用户就只需要在80端口上进行交互就可以了，这样就避免了跨域问题，因为我们都是在80端口上进行交互的
nginx实现跨域的原理，实际就是把web项目和后端接口项目放到一个域中，这样就不存在跨域问题，然后根据请求地址去请求不同服务器
```

# 第三部分: 数据库/中间件

### 29.索引

```
为什么要有索引:
1.通过创建唯一性索引 保证数据库每一行数据的唯一性
2.加快数据检索速度 减少每次检索牵涉的数据量
3.帮助服务器避免排序和临时表
4.将随机IO变为顺序IO
    随机IO: 由于数据不是连续存储 需要多次从硬盘中读取多段数据到内存 每段数据只会用到一小部分
    顺序IO: 从硬盘读取连续的一段数据到内存
5.加速表和表之间的连接

哈希索引和BTree索引的区别:
  1. 哈希索引定位快 适用于等值查询
  2. 大量重复键值情况下的哈希冲突问题
  3. 哈希索引不支持顺序和范围查询
  4. 哈希索引不支持多列联合索引的最左匹配规则

BTree索引和B+Tree索引的区别(见桌面图):
  1. B 树的所有节点既存放 键(key) 也存放 数据(data);而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
  2. B 树的叶子节点都是独立的; B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
  3. B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。
     而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

MyISAM索引实现, InnoDB索引实现:
见桌面图(包含非聚簇索引和聚簇索引,主键索引和辅助索引的概念)

非聚簇索引和聚簇索引:
  非聚簇索引:B+Tree叶节点的data域存放的是数据记录的地址
  聚簇索引:B+Tree叶节点的data域存放的是数据

InnoDB 支持哪种索引:
  InnoDB        BTree
  MyISAM        BTree
  Memory/Heap   Hash, BTree

全文索引:
  1.原理
    先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳，这样就相当于对文件建立了一个以词库为目录的索引，这样查找某个词的时候就能很快的定位到该词出现的位置。
  2.问题
    在处理英文文档的时候显然这样的方式是非常好的，因为英文自然的被空格分成若干词，只要我们有足够大的词汇库就能很好的处理。
    但是亚洲文字因为没有空格作为断词标志，所以就很难判断一个词，而且人们使用的词汇在不断的变化，而维护一个可扩展的词汇库的成本是很高的，所以问题出现了。
  3.解决  
    二元法 它把所有有可能的每两两汉字的组合看为一个词组，这样就没有维护词库的开销。
    词库法 它使使用词库中的词作为切分的标准，但出现了词库跟不上词汇发展的问题，除非你维护词库。

唯一索引:
  不允许具有索引值相同的行，从而禁止重复的索引或键值。系统在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句添加数据时进行检查。

```

### 30.事务,ACID,并发事务的4个问题,事务隔离级别
```
事务的定义:
逻辑上的一组操作 要么都执行 要么都不执行

ACID:
原子性 Atomicity :事务是最小的执行单位 不可分割 事务的一组操作要么都执行 要么都不执行
一致性 Consistency :数据在事务执行前后保持一致 如转账前后收款人和付款人的总额一致
隔离性 Isolation : 并发访问数据库时 一个用户的事务不会被其他事务所干扰 各并发事务对数据库的影响是独立的
持久性 Durability 事务提交之后 它对数据库中数据的改变是持久的 即使数据库发生故障也不会影响这种改变

MySQL 的哪个引擎支持事务:
InnoDB

并发事务的4个问题:
见桌面图

事务的隔离级别:
见桌面图

MySQL 默认的事务隔离级别:
可重复读
```

### 31.SQL 语句增删改查
```
增
INSERT INTO Customers(id, name)
VALUES('001', 'Toy');

删
DELETE FROM Customers
WHERE id = '001';

改
UPDATE Customers
SET email = 'qq.com'
WHERE id = '001';

查
SELECT name, price
FROM Products
WHERE price = 3.49;

```
### 32.SQL JOIN LEFT JOIN RIGHT JOIN
    - left join 和 right join 的区别
```    
左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。        
右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。

调整FROM子句中表的顺序, 左外联结和右外联结可以相互转换


```

### 33.存储过程
    - 什么是存储过程
```
为以后使用而保存的一条或多条SQL语句
```

### 34.视图
    - 什么是视图
```
视图是将一个查询包装成一个带名字的虚拟表 然后可以通过该虚拟表检索需要的数据

CREATE VIEW ProductsCustomers AS
SELECT ...
FROM ...
WHERE ...
```

### 35.Redis 常见作用
    - 见36

### 36.Redis 常见数据结构以及使用场景:
    - 几种, 分别是什么, 特点是什么
```
1. string 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量
2. list 发布与订阅或者说消息队列、慢查询
3. hash 系统中对象数据的存储(用户信息，商品信息)
4. set 需要存放的数据不能重复以及需要获取多个数据源交集(共同关注、共同粉丝)和并集等场景
5. sorted set 需要对数据根据某个权重进行排序的场景(直播间按VIP等级排列的在线用户，各种礼物排行榜)
6. bitmap 适合需要保存状态信息并需要进一步对这些信息进行分析的场景(用户签到和活跃情况、用户行为统计)

```

### 37.Redis 为何快
    - 基于内存
    - 单线程
    - 拓展: IO 多路复用


### 38.消息队列的作用
    - 为什么要用消息队列, 能解决什么问题
    - 应用场景. 异步,削峰
```
为什么要用消息队列:
  1.通过异步处理提高系统性能（减少响应所需时间）。
      将用户的请求数据存储到消息队列之后就立即返回结果, 随后系统再对消息进行处理。
  2.削峰/限流
      先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去处理这些消息，避免后端崩溃。
      在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击
  3.降低系统耦合性。
      消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合
      对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。
```


### 39.RPC 和 RESTful
    - RPC 是什么, 优点是什么
    - RESTful 是什么, 优点是什么

```
RPC (Remote Procedure Call 远程过程调用)
  通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节

RESTful (REpresentational State Transfer 表现层状态转化)
  RESTful API 可以让用户看到 url + http method 就知道这个 url 是干什么的，让你看到了 http 状态码（status code）就知道请求结果如何。

```

### 40.Nginx
    - Nginx 是什么, 有什么优点
```
Nginx
轻量级的Web服务器、反向代理服务器
将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性
```

# 第四部分: 操作系统

### 41.进程状态 进程间通信方式 线程间同步方式 进程的调度算法
    - CPU 分时
    - 进程线程的调度
        - 为甚要调度

```
进程的5种状态:
见桌面图

进程间通信方式:
1.匿名管道
2.有名管道
3.信号
4.消息队列
5.信号量
6.共享内存
7.套接字

线程间同步方式:
1.互斥量
2.信号量
3.事件[消息传递 例如wait()/notify()]

进程的调度算法:
1.先到先服务
2.短作业优先
3.时间片轮转
4.多级反馈队列
  规则1：如果A的优先级>B的优先级，运行A（不运行B）。
  规则2：如果A的优先级=B的优先级，轮转运行A和B。
  规则3：作业进入系统时，放在最高优先级（最上层队列）。
  规则4：一旦作业用完了其在某一层中的时间配额，就降低其优先级（移入低一级队列）。
  规则5：经过一段时间S，就将系统中所有作业重新加入最上层队列。
5.优先级调度

为什么需要调度:
为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率
```

### 42.虚拟内存技术[操作系统内存管理机制 快表 多级页表 分页和分段比较 页面置换算法]
```
操作系统内存管理机制
1.块式
2.页式 页比块小 页无实际意义 通过页表管理页
3.段式 段比页更小 段有实际意义(主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等) 通过段表管理段
4.段页式 结合页式和段式的优点 主存分成若干段 每段分成若干页

快表(类比缓存):
1.根据虚拟地址中的页号查快表；
2.如果该页在快表中，直接从快表中读取相应的物理地址；
3.如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4.当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

多级页表如何节约内存:
https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html

分页和分段比较:
1.共同点
    分页机制和分段机制都是为了提高内存利用率，减少内存碎片。
    页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。
2.区别
    页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
    分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

页面置换算法:
OPT 页面置换算法（最佳页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
FIFO（First In First Out） （先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用次数最少的页面作为淘汰页。

```
# 第五部分: Linux 相关

### 43.查看进程

### 44.杀进程

### 45.看日志
    - 日志位置
    - 看日志命令

### 46.修改权限
    - 用户分组
    - 有哪些权限
    - 命令

### 47.压缩解压

### 48.脚本
    - 怎么运行 shell 脚本
    - shell 脚本怎么在出错的时候停下来
        - set -eux

### 49.监控系统资源
    - cpu, 内存, 硬盘

# 第六部分: Spring

### 50.Spring 和 Spring MVC 和 Spring Boot
    - 分别是做什么用的
    - Spring 有哪些功能
        - 控制反转, 依赖注入
        - 常用的依赖注入方式
        - 拓展: 原理是什么. 就是怎么扫描类, 怎么生成实例

### 51.Spring Boot:
    - 为什么要有 Spring Boot
    - 有几种配置方式
    - 拓展: 怎么加载配置的

### 52.Spring MVC:
    - 什么是 Spring MVC
    - 处理请求的流程:
        - 哪个类或者实例处理
    - 怎么拿到前端传的参数
        - 拿参数的几种方式
        - 拓展: 怎么解析前端拿到的参数
    - 路由怎么返回
        - 说一下大概有几种
        - 说自己日常用的那种

### 53.Servlet
    - 为什么要有 Servlet
    - 有哪几个方法

### 54.依赖注入和控制反转和 Spring bean
    - 什么是依赖注入(DI)
    - 什么是控制反转(IOC), 模式
    - Spring bean 是什么

### 55.AOP(面向切面编程)
    - 什么是切面
    - 为什么要面向切面编程
    - 可以用来做什么
    - 怎么用, 你平常怎么匹配切面, 怎么插入代码

### 56.Spring bean 注解:
    - 有哪些注解
    - 我们用到了哪些注解, 是什么框架提供的(Spring MVC 还是 mybatis 还是 Spring)

### 57.Spring 自动装配模式有哪些, 有什么区别
    - 什么是自动装配.
    - 有几种模式
    - 上课用过哪几种

### 58.Spring 管理事务:
    - 用法
    - 事务作用范围, 回滚规则

# 第七部分: 算法题
### 59.hashmap
    - 原理, 怎么实现的

### 60.快排

# 附录: web简答
```
1.浏览器访问localhost:9000的流程
2-5留言、登录、注册、增加todo的流程
6.cookie存储位置 cookie在服务器端如何设置 发往服务器的请求头附带的字段
7.摘要的原理
8.非对称加密原理 对称加密和非对称加密的区别
9.证书体系的原理
10.https原理和流程
11.session机制和流程,解决的问题,服务器端session的实现方式
12.模板
13.AJAX如何使用
14.JS中事件的添加流程
15.JS的回调机制,JS需要回调的原因
16.进程和线程
17.栈和堆
18.线程安全和原子性
19.死锁
20.自动垃圾回收
21.内存泄漏
22.hashset 为什么能达到 O(1) 的时间复杂度？ https://zhuanlan.zhihu.com/p/79507868
23. CSRF  https://zhuanlan.zhihu.com/p/37293032
24. XSS https://zhuanlan.zhihu.com/p/26177815
25. 验证码
26. 数据库事务
27. 为什么要有索引
28. 索引原理, 底层的数据结构, 哈希索引和B树索引的区别, InnoDB 支持哪种索引?
29. 聚簇索引和非聚簇索引,唯一索引,主键索引和二级索引
30. Redis (定义,主要用途及使用Redis原因,项目中使用)
```
