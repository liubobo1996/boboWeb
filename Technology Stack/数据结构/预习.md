### 1. 算法分析
### . 数据结构

算法
就是一个操作指南, 一个菜谱
告诉你先做什么, 再做什么, 最后实现一个目的

什么是算法, 比如给数组排序
4 3 1 7
1 3 4 7

算法分析: 对一个算法耗费资源的大略估计
时间复杂度
空间复杂度

对于耗费资源的计算

A 方案: 1s, 100 MB
B 方案: 2s, 10 MB

函数 A, 调用一次 10s, 调用 N 次, 10 * N
函数 B, 调用一次 1s, 调用 N 次耗时 1 * N * N

A 跑 10次, 100s
B 跑 100次, 10000s

1. 抛开平台和具体实现的影响
2. 要考虑到调用次数的增多, 对于总耗时的影响

随着调用次数的增长, 算法总的操作数量的一个估算
叫 大 O 阶, 用个数学符号来代替, O(N)
N 代表输入的规模


public static void A(int n) {
    for (int i = 0; i < n; i++) {
        Utils.log("this is A"); // 单条语句耗费时间x
        Utils.log("this is A"); // 单条语句耗费时间x
        Utils.log("this is A"); // 单条语句耗费时间x
        Utils.log("this is A"); // 单条语句耗费时间x
    }
    // 耗费时间 4 * x * n
}

public static void B(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            Utils.log("this is B"); // 单条语句耗费时间x
        }
    }
    Utils.log("this is B"); // 单条语句耗费时间x
    // 耗费时间 x * n * n + x
}

n < 2, 4x, x
n =  2, 8x, 4x
n = 3, 12x, 9x
n = 4, 16x, 16x
n = 5, 20x, 25x


O(N) = 4n, 记作 O(4n)
O(N)  = n ^ 2, 记做 O(n ^ 2)

400
10000


函数A总时间 = 4 * x * N
           = 4xN

O(4xN) -> O(N)

函数B总时间 = x * n * n + x
           = x * n ^ 2 + x

O(x * n ^ 2 + x) =  O(n ^ 2 + 1) =  O(n ^ 2)


技巧
1. 把相乘的常量当成 1
2. 相加的常量变成 0


算法的时间复杂度
--------------

- 大 O 记法，是描述算法复杂度的符号
- 时间复杂度说的是算法的运行时间随着数据规模的增长而增长的幅度
- 空间复杂度就是占用内存的多少
A方案: 1s, 100 MB 内存
B方案: 2s, 10 MB 内存

- O(1)
    - 常数复杂度，代表时间复杂度最低的算法。
    - 取数组前一万个元素的和
    - 字典和集合的存取都是 O(1)
    - 用下标进行数组的存取是 O(1)
        address + size(element) * 100
        - `a[1]` `a[2]`
- O(logN)  实际上是(log 2 N)
    - 对数复杂度
    - `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
      2 的 n 次方 >= 10
      n = 4;
      最慢的情况下就要查找 log10 次,  log10 * x
      如果数据规模是 n, 平均每次查找用 x, 总时间是 logN * x, 时间复杂度就是 logN
    - 假设有一个有序数组，以二分法查找
    - 1000 500 250 .... 0
    - 2^n = 1000 -> n = log2(1000) -> n = 10
- O(N)
    - 线性复杂度
    - `[3, 4, 7, 1, 2, 6, 5, 9, 10, 8]`
    - x * n -> O(x * n) -> O(n)
    - 取数组所有元素的和
    - 假设有一个无序数组，以遍历的方式在其中查找元素

- O(MlogN) O(NlogN)
    - 求两个数组交集，其中 A 为无序数组， B 为有序数组
    假设遍历每步用时 x, 比较每步用时是 y,
    A 里面有 M 个元素, B 里面有 N 个元素
    一个元素在 B 里面查找, 耗时是  logN * y
    A 里面所有元素在 B 里面都找一遍, M * x * logN * y
    MlogN * xy
    时间复杂度就是 M*logN

    - `[3, 4, 7, 1, 2, 6, 5, 9, 10]` `[1, 3, 11]`
    - A 有 M 个元素，B 有 N 个元素
    - A 数组每一个元素都要在 B 数组中进行查找操作
    - 每次查找如果使用二分法则复杂度是 O(logN)
    - 查找 M 次 即是 O(M)
    - 总的就是 O(M) * O(logN) = O(MlogN)
- O(N^2) O(M*N)
    - 平方复杂度
    - 求两个长度一样的无序数组的交集
    - 求长度为 M 和长度为 N 的两个无序数组的交集
    - `[3, 4, 7, 1, 2, 6, 5, 9, 10, 8]` `[3, 1, 13]`
    - M * N, N ^ 2
    



四大数据结构
------------

针对常用的操作，我们总结了一套常用的数据结构
数据结构就是存储、操作数据的方式
存, 取, 查, 删

1. 数组  array
    - 连续的一块存储空间
    - 读取元素时间是 O(1)
    - 插入末尾是 O(1)
    - 插入、删除是 O(n),
       因为数组要求是连续的空间, 不能有空格,
       所以插入和删除都要移动修改插入或者删除位置之后的元素
       123456789
       12345 789
       123457 89
       1234578 9
       12345789

       删除 k 位置的数据, 如果有 n 个元素
       移动 n - k 个数据
       移动一个元素, 耗费时间 y
       (n - k) * y -> n - k -> O(n)
    -
2. 链表 linked list
    - 手拉手的盒子，一个盒子只能访问左右手的盒子
    - 以下标方式读取元素的时间是 O(n), n 下标
    - 找到节点后, 插入、删除是 O(1)
    - 栈和队列是链表的改良型

栈和队列
栈是先进后出, 相当于往水桶里面放东西, 先放进去的最后才能取出来
队列是先进先出, 相当于排队


3. 字典, 哈希表, HashMap, HashTable
m.put("age", 333)
m.pug("name", 4444)


    - 把字符串转为数字作为下标存储到数组中
    - 字符串转化为数字的算法是 O(1)
    - 所以字典的存取操作都是 O(1)
    - 除非对数据有顺序要求，否则字典永远是最佳选择
    - 字符串转化为数字的算法 hash 哈希
        1. 确定数据规模，这样可以确定容器数组的大小 size
        2. 把字符当作 10 进制数字得到结果
            - 'gua' 被视为 g * 1 + u * 10 + a * 100 得到结果 n
            - n % size 作为字符串在数组中的下标
            - 通常 size 会选一个 素数
            - 用链表法解决碰撞
            - rehash
4. 二叉搜索树（我们只用，不写，甚至只是隐含在用，你并不知道你用的是树）
    - 搜索, 删除, 查找的复杂度, 都是 O(log(n)), n 是节点数量
    - AVL 树，名字三个作者的缩写
    - 红黑树，非常难，世界上没几个人会

二叉树: 子节点最多只有两个子树(节点)
二叉搜索树: 如果有左树, 那么左树上所有节点的值, 都小于根节点的值; 右树反之, 所有节点的值, 都大于根节点的值
搜索, 删除, 查找的复杂度, 都是 O(log(n)), n 是节点数

平衡: 左右树的高度, 相差不超过 1, 就是平衡的
平衡二叉搜索树, 插入和删除的时候, 都要保持树的平衡, 这个平衡的操作, 就是树的旋转
AVL 树
红黑树

5. 图
    - 额外的，图是一种有时候有用但你一辈子都可能写不到的数据结构
    - 只了解，不用学习如何实现
    - 图的应用举例
        - 地图导航
        - 全国几个大城市之间的出行方案(有价格/时间/路途等权重)


Set 集合
里面的元素不会重复


